## Крипто Order Book — Архитектура и решения по производительности

Этот документ описывает архитектурные решения, лежащие в основе виджета **Crypto Order Book**, с акцентом на производительность, поток данных и корректность работы при высокочастотных обновлениях.

---

## 1. Общий обзор

Приложение отображает криптовалютный стакан (Bids / Asks) в реальном времени, используя данные из WebSocket-потока. Входящие обновления могут превышать **100 сообщений в секунду**, поэтому ключевая цель архитектуры:

> **Отделить приём данных от рендеринга UI**, чтобы избежать зависаний интерфейса и лишних перерисовок.

Для этого архитектура разделена на три слоя:

1. **Транспортный слой** — WebSocket-соединение и декодирование протокола
2. **Слой обработки** — буферизация, группировка, сортировка (Web Worker)
3. **Слой представления** — ограниченный по FPS React-рендеринг + Canvas-оверлей

---

## 2. Поток данных

```
WebSocket
   ↓
BinaryDecoder (обязательный протокольный слой)
   ↓
In-memory buffer (useRef)
   ↓   (ограничение 10 FPS)
Снимок состояния React
   ↓
Web Worker (группировка + сортировка)
   ↓
React UI + Canvas overlay
```

Ключевой принцип:

> **Сообщения WebSocket никогда напрямую не вызывают рендер React.**

---

## 3. Интеграция BinaryDecoder

Несмотря на то, что Binance отправляет данные в формате JSON, все входящие сообщения проходят через предоставленный класс `BinaryDecoder`.

Причины:

* Имитация проприетарного бинарного протокола
* Принудительное явное маппирование полей (цена, объём, sequence)
* Возможность отслеживания последовательности пакетов и обнаружения рассинхронизации

Это гарантирует, что UI-слой никогда не работает напрямую с «сырыми» данными сокета.

---

## 4. Буферизация и троттлинг (10 FPS)

Входящие сообщения WebSocket записываются в изменяемый буфер:

* Используется `useRef`, чтобы не вызывать перерисовки
* Данные постоянно перезаписываются с максимальной скоростью сокета

С помощью `setInterval` (каждые 100 мс) в React-state публикуется **снимок** буфера.

Почему выбран именно этот подход:

* Предсказуемая частота рендера (10 FPS)
* UI остаётся отзывчивым под нагрузкой
* Проще и надёжнее, чем debounce каждого сообщения

Это напрямую удовлетворяет требованию задания:

> *«UI не должен обновляться на каждое сообщение сокета»*

---

## 5. Вынос вычислений в Web Worker

Группировка по шагу цены (tick size) и сортировка — CPU-затратные операции. Чтобы не блокировать основной поток:

* Используется отдельный **Web Worker**, который выполняет:

  * группировку цен
  * агрегацию объёмов
  * сортировку

Главный поток передаёт в воркер только:

```ts
{ bids, asks, tick }
```

И получает обратно:

```ts
{ groupedBids, groupedAsks }
```

Это гарантирует плавную работу UI даже при высокой нагрузке.

---

## 6. Рендеринг через Canvas overlay

Визуализация глубины рынка (объёмные бары) реализована через один `<canvas>`:

* Избегает создания сотен DOM-элементов
* Обеспечивает быстрые перерисовки
* Соответствует реальным интерфейсам бирж

Canvas располагается под HTML-строками, сочетая:

* Canvas → производительность
* HTML → доступность и удобство вёрстки

---

## 7. Обнаружение рассинхронизации / пропусков sequence

Каждое декодированное сообщение содержит номер `sequence`.

Логика:

* Хранится последний обработанный sequence
* Если `current !== last + 1` — обнаружен разрыв

При обнаружении рассинхронизации:

* В UI отображается визуальное предупреждение
* Это полезно для диагностики потери данных или проблем с сетью

---

## 8. Особенности React 18 StrictMode

В режиме разработки React 18 намеренно монтирует компоненты дважды.

Чтобы избежать дублирования WebSocket-соединений:

* Жизненный цикл подключения защищён через `useRef`
* В любой момент времени существует только одно активное соединение

Это предотвращает:

* Дублирующиеся подключения
* Ложные ошибки отключения

---

## 9. TypeScript и безопасность типов

* Везде используется строгая типизация
* Отсутствуют `any`
* Явные контракты данных между слоями

Преимущества:

* Упрощённый рефакторинг
* Безопасное взаимодействие с Web Worker
* Чёткое разделение ответственности компонентов

---

## 10. Итог

Данная архитектура ориентирована на:

* Производительность при высокочастотных обновлениях
* Чёткое разделение обязанностей
* Реалистичные production-паттерны

Результат — отзывчивая и масштабируемая реализация Order Book, пригодная для реальных торговых интерфейсов.


